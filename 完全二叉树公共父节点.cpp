/*有一棵无限大的完全二叉树，该二叉树自上而下、自左而右从1开始编号。从某一个结点到根结点（编号是1的结点）都有一条唯一的路径，比如从5到根结点的路径是（5, 2, 1），从4到根结点的路径是（4, 2, 1），从根结点1到根结点的路径上只包含一个结点1，因此路径就是（1）。对于两个结点x和y，假设他们到根结点的路径分别是（x1, x2, ... ,1）和（y1, y2,...,1），那么必然存在两个正整数i和j，使得从xi 和yj 开始，有xi = yj，xi + 1 = yj + 1，xi + 2 = yj + 2，...
现在的问题就是，给定x和y，要求他们的最近公共父节点，即xi（也就是 yj）。
输入格式
	输入包含多组数据，每组数据包含两个正整数x和y（1≤x, y≤2^31-1），x=0、y=0表示输入结束。
输出格式
	对应每一组数据，输出一个正整数xi，即它们的首个公共父节点。每输出一个数字后要换行。
样例输入
10 4
0 0
样例输出
2
样例说明
结点10到根结点的路径为（10,5,2,1），结点4到根节点的路径为（4,2,1），所以他们的首个公共父结点为2。*/
#include<stdio.h>
#include<stdbool.h>
#define MAX_SIZE 100
int main(){
	int x=1,y=1;//初始化，不为0即可
	int tem[2][MAX_SIZE]={0};
	int result[MAX_SIZE]={0};
	int i,j,k=0;
	while(true){
		scanf("%d %d",&x,&y);
		if(x==0&&y==0)
		break;
		i=0;
		int xn,yn;
		while(x!=0){
			tem[0][i]=x;
			i++;
			x/=2;
		}
		xn=i;
		i=0;
		while(y!=0){
			tem[1][i]=y;
			i++;
			y/=2;
		}
		yn=i;
		for(i=0;i<xn;i++){
			for(j=0;j<yn;j++){
				if(tem[0][i]==tem[1][j]){
					result[k]=tem[1][j];
					k++;
					break;
				}	
		}//跳出第二重循环
		if(j!=yn){
			break;
		}
	}
}
	for(i=0;i<k;i++){
		printf("%d\n",result[i]);
	}
	return 0;
}
